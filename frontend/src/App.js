import React, {useState, useRef } from 'react';
import { DndProvider} from 'react-dnd';
import { HTML5Backend } from 'react-dnd-html5-backend';
import Bucket from './dnd/Bucket.js';
import Box from './dnd/Box.js';
import Trash from './dnd/Trash.js';


function App() {
  const [droppedItems, setDroppedItems] = useState({
    0: {
      0: [],
      1: [],
      2: [],
      3: []
    },
    1: {
      0: [],
      1: [],
      2: [],
      3: []
    },
    2: {
      0: [],
      1: [],
      2: [],
      3: []
    },
    3: {
      0: [],
      1: [],
      2: [],
      3: []
    }



  });
  const [queryResults, setQueryResults] = useState([]);
  const [mongoQuery, setMongoQuery] = useState([]);
  const resultRef = useRef(null);
  const queryRef = useRef(null);

  const clearDroppedItems = () => {
    setDroppedItems({
      0: {
        0: [],
        1: [],
        2: [],
        3: []
      },
      1: {
        0: [],
        1: [],
        2: [],
        3: []
      },
      2: {
        0: [],
        1: [],
        2: [],
        3: []
      },
      3: {
        0: [],
        1: [],
        2: [],
        3: []
      }
    });
  }

  const handleDrop = (item, bucketId, stageId) => {
    /**
     * Process a draggable object and store the information to the droppedItems variable.
     * 
     * @param {Object} item - The input object from the draggable object.
        * @param {number} item.stageId - The stage # the item is currently stored in.  Does not exist if not in a bucket.
        * @param {number} item.bucketId - The bucket # the item is currently stored in.  Does not exist if not in a bucket.
        * @param {datetime} item.id - Unique id associated with each individual item generated by Date.now(). Does not exist if not in a bucket.
     * @param {number} bucketId - The id of bucket that the item is dropped into.
     * @param {number} stageId - The id of the stage that the item is dropped into.
     * @returns {void}
     **/

    //Handle bucket change
    if (item.id) {
      //Remove item from original bucket
      setDroppedItems((prevItems) => (
        {
          ...prevItems,
          [item.stageId]: {
            ...prevItems[item.stageId],
            [item.bucketId]:
              prevItems[item.stageId][item.bucketId].filter(
                prevItem => prevItem.id !== item.id
              )
          }

        }
      ));
      //Place existing item into new bucket
      let newItem = { ...item, stageId: stageId, bucketId: bucketId }
      setDroppedItems((prevItems) => (
        {
          ...prevItems,
          [stageId]: {
            ...prevItems[stageId],
            [bucketId]: [
              ...prevItems[stageId][bucketId],
              newItem]
          }
        }
      )
      );
    //Handle new item drop when dragged from the top.
    } else {
      let newItem = { ...item, id: Date.now(), stageId: stageId, bucketId: bucketId }
      setDroppedItems((prevItems) => (
        {
          ...prevItems,
          [stageId]: {
            ...prevItems[stageId],
            [bucketId]: [
              ...prevItems[stageId][bucketId],
              newItem]
          }
        }
      )
      );
    }
  };

  const handleRemoveItem = (item) => {
     /**
     * Remove item stored in droppedItem.
     * 
     * @param {Object} item - The input object from the draggable object.
        * @param {number} item.stageId - The stage # the item is currently stored in.  Does not exist if not in a bucket.
        * @param {number} item.bucketId - The bucket # the item is currently stored in.  Does not exist if not in a bucket.
     * @returns {void}
     **/
    if (item.id) {
      setDroppedItems((prevItems) => (
        {
          ...prevItems,
          [item.stageId]: {
            ...prevItems[item.stageId],
            [item.bucketId]:
              prevItems[item.stageId][item.bucketId].filter(
                prevItem => prevItem.id !== item.id
              )
          }
        }
      ));
    }
  };

  const onValueChange = (e, id, bucketId, stageId) => {
     /**
     * Edit values of item stored in droppedItem that is also currently in a bucket.
     * 
     * @param {Object} e - Passed in through the event trigger that contains the field values.
     *  @param {Object} e.target.name - The name of the input field.
     *  @param {Object} e.target.value - The value of the input field.
     * @param {datetime} id - Unique id to identify item generated by Date.now() function
     * @param {number} bucketId - The bucket # the item is currently stored in.
     * @param {number} stageId - The stage # the item is currently stored in.  
     * @returns {void}
     **/

    if (id) {  // Only change values of draggable element that is already placed in bucket.
      setDroppedItems((prevItems) => (
        {
          ...prevItems,
          [stageId]: {
            ...prevItems[stageId],
            [bucketId]: prevItems[stageId][bucketId].map((prevItem) => {

              if (prevItem.id !== id) {
                return prevItem;
              }

              let name = e.target.name
              let value = e.target.value

              if (name === 'input') {
                return { ...prevItem, inputValue: value }
              } else if (name === 'operator') {
                return { ...prevItem, operator: value }
              } else if (name === 'key') {
                return { ...prevItem, keyValue: value }
              }
            })
          }
        }
      ))
    }
  }

  const query = async () => {
    fetch('http://localhost:8000/query', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(droppedItems)
    })
      .then((response) => response.json())
      .then((data) => {
        setQueryResults(data.result);
        setMongoQuery(data.mongoQuery)
        resultRef.current?.scrollIntoView({ behavior: 'smooth' })
      })
  }

  return (
    <DndProvider backend={HTML5Backend}>
      <div style={{
        backgroundColor: 'grey',
        display: 'flex',
      }}>
        <div style={{ width: '5%' }}></div>
        <Box />
        <button onClick={query}>Run</button>
        <button onClick={clearDroppedItems}>Clear Items</button>
        <Trash onDrop={handleRemoveItem} />
      </div>

      {Object.entries(droppedItems).map(([stageId]) => (
        <>
          <h3
            style={{
              textAlign: 'center'
            }}
          >
            Stage {parseInt(stageId) + 1}
          </h3>

          <div
            style={{
              display: 'flex',
              justifyContent: 'space-between',
              width: '100%',
            }}
          >
            {Object.entries(droppedItems[stageId]).map(([bucketId]) => (
              <div style={{
                flex: '1',
                float: 'left',
                borderStyle: 'solid',
                borderColor: 'black',
                height: '20vh',
              }}>
                <Bucket
                  key={bucketId}
                  id={bucketId}
                  stageId={stageId}
                  onDrop={handleDrop}
                  style={{
                    height: 'inherit'
                  }}
                >
                  {droppedItems[stageId][bucketId].map((data) => (
                    <Box key={data.id} id={data.id} bucketId={bucketId} stageId={stageId} keyValue={data.keyValue} operator={data.operator} inputValue={data.inputValue}
                      onValueChange={(e) => onValueChange(e, data.id, bucketId, stageId)}>
                    </Box>
                  ))}
                </Bucket>
              </div>
            ))}
          </div>
        </>

      ))}
      <h2>Query Results</h2>
      <div ref={resultRef}>
        {queryResults.map((result, index) => (
          <li key={index}>
            <pre>{JSON.stringify(result, null, 2)}</pre>
          </li>
        ))}

      </div>
      <h2>Mongo Query Object</h2>
      <pre ref={queryRef}>{JSON.stringify(mongoQuery, null, 2)}</pre>
    </DndProvider>
  );
}

export default App;
